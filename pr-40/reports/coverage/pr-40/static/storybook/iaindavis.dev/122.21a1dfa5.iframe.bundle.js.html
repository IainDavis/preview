
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for pr-40/static/storybook/iaindavis.dev/122.21a1dfa5.iframe.bundle.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">pr-40/static/storybook/iaindavis.dev</a> 122.21a1dfa5.iframe.bundle.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/754</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/498</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/175</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >(self.webpackChunkiaindavis_dev=self.webpackChunkiaindavis_dev||[]).push([[122],{"./node_modules/@storybook/blocks/dist/Color-ERTF36HU.mjs":<span class="fstat-no" title="function not covered" >(_</span>_unused_webpack_module,__webpack_exports__,__webpack_require__)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{ColorControl:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ColorControl,</span>default:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Color_default}</span>);v</span>ar chunk_MKV36LKP=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/@storybook/blocks/dist/chunk-MKV36LKP.mjs"),</span>react=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/react/index.js"),</span>components=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/@storybook/core/dist/components/index.js"),</span>theming=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/@storybook/core/dist/theming/index.js"),</span>dist=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/@storybook/icons/dist/index.mjs"),</span>color_convert=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/color-convert/index.js"),</span>color_convert_default=<span class="cstat-no" title="statement not covered" >__webpack_require__.n(color_convert),</span>debounce=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/lodash/debounce.js"),</span>debounce_default=<span class="cstat-no" title="statement not covered" >__webpack_require__.n(debounce);</span>function <span class="fstat-no" title="function not covered" >u(</span>){<span class="cstat-no" title="statement not covered" >return(u=Object.assign||<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;arguments.length;r++){var t=<span class="cstat-no" title="statement not covered" >arguments[r];<span class="cstat-no" title="statement not covered" ></span>for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,n)&amp;&amp;(e[n]=t[n])}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e}</span>).apply(this,arguments)}</span>function <span class="fstat-no" title="function not covered" >c(</span>e,r){<span class="cstat-no" title="statement not covered" >if(null==e)<span class="cstat-no" title="statement not covered" >return{};v</span></span>ar t,n,o=<span class="cstat-no" title="statement not covered" >{},</span>a=<span class="cstat-no" title="statement not covered" >Object.keys(e);<span class="cstat-no" title="statement not covered" ></span>for(n=0;n&lt;a.length;n++)<span class="cstat-no" title="statement not covered" >r.indexOf(t=a[n])&gt;=0||(o[t]=e[t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>function <span class="fstat-no" title="function not covered" >i(</span>e){var t=<span class="cstat-no" title="statement not covered" >(0,react.useRef)(e),</span>n=<span class="cstat-no" title="statement not covered" >(0,react.useRef)((<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >t.current&amp;&amp;t.current(e)}</span>));<span class="cstat-no" title="statement not covered" ></span>return t.current=e,n.current}</span>var s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e,r,t){<span class="cstat-no" title="statement not covered" >return void 0===r&amp;&amp;(r=0),void 0===t&amp;&amp;(t=1),e&gt;t?t:e&lt;r?r:e}</span>,</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >return"touches"in e}</span>,</span>v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e.ownerDocument.defaultView||self}</span>,</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e,r,t){var n=<span class="cstat-no" title="statement not covered" >e.getBoundingClientRect(),</span>o=<span class="cstat-no" title="statement not covered" >f(r)?<span class="fstat-no" title="function not covered" >function(</span>e,r){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.length;t++)<span class="cstat-no" title="statement not covered" >if(e[t].identifier===r)<span class="cstat-no" title="statement not covered" >return e[t];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e[0]}</span>(r.touches,t):r;<span class="cstat-no" title="statement not covered" ></span>return{left:s((o.pageX-(n.left+v(e).pageXOffset))/n.width),top:s((o.pageY-(n.top+v(e).pageYOffset))/n.height)}}</span>,</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >!f(e)&amp;&amp;e.preventDefault()}</span>,</span>m=<span class="cstat-no" title="statement not covered" >react.memo((<span class="fstat-no" title="function not covered" >function(</span>o){var a=<span class="cstat-no" title="statement not covered" >o.onMove,</span>l=<span class="cstat-no" title="statement not covered" >o.onKey,</span>s=<span class="cstat-no" title="statement not covered" >c(o,["onMove","onKey"]),</span>m=<span class="cstat-no" title="statement not covered" >(0,react.useRef)(null),</span>g=<span class="cstat-no" title="statement not covered" >i(a),</span>p=<span class="cstat-no" title="statement not covered" >i(l),</span>b=<span class="cstat-no" title="statement not covered" >(0,react.useRef)(null),</span>_=<span class="cstat-no" title="statement not covered" >(0,react.useRef)(!1),</span>x=<span class="cstat-no" title="statement not covered" >(0,react.useMemo)((<span class="fstat-no" title="function not covered" >function(</span>){var e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >h(e),(f(e)?e.touches.length&gt;0:e.buttons&gt;0)&amp;&amp;m.current?g(d(m.current,e,b.current)):t(!1)}</span>,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>){<span class="cstat-no" title="statement not covered" >return t(!1)}</span>;</span>function <span class="fstat-no" title="function not covered" >t(</span>t){var n=<span class="cstat-no" title="statement not covered" >_.current,</span>o=<span class="cstat-no" title="statement not covered" >v(m.current),</span>a=<span class="cstat-no" title="statement not covered" >t?o.addEventListener:o.removeEventListener;<span class="cstat-no" title="statement not covered" ></span>a(n?"touchmove":"mousemove",e),a(n?"touchend":"mouseup",r)}<span class="cstat-no" title="statement not covered" ></span>return[<span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >e.nativeEvent,</span>n=<span class="cstat-no" title="statement not covered" >m.current;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;(h(r),!<span class="fstat-no" title="function not covered" >function(</span>e,r){<span class="cstat-no" title="statement not covered" >return r&amp;&amp;!f(e)}</span>(r,_.current)&amp;&amp;n)){<span class="cstat-no" title="statement not covered" >if(f(r)){<span class="cstat-no" title="statement not covered" >_.current=!0;v</span>ar o=<span class="cstat-no" title="statement not covered" >r.changedTouches||[];<span class="cstat-no" title="statement not covered" ></span>o.length&amp;&amp;(b.current=o[0].identifier)}<span class="cstat-no" title="statement not covered" ></span>n</span>.focus(),g(d(n,r,b.current)),t(!0)}</span>}</span>,<span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >e.which||e.keyCode;<span class="cstat-no" title="statement not covered" ></span>r&lt;37||r&gt;40||(e.preventDefault(),p({left:39===r?.05:37===r?-.05:0,top:40===r?.05:38===r?-.05:0}))}</span>,t]}</span>),[p,g]),</span>C=<span class="cstat-no" title="statement not covered" >x[0],</span>E=<span class="cstat-no" title="statement not covered" >x[1],</span>H=<span class="cstat-no" title="statement not covered" >x[2];<span class="cstat-no" title="statement not covered" ></span>return(0,react.useEffect)((<span class="fstat-no" title="function not covered" >function(</span>){<span class="cstat-no" title="statement not covered" >return H}</span>),[H]),react.createElement("div",u({},s,{onTouchStart:C,onMouseDown:C,className:"react-colorful__interactive",ref:m,onKeyDown:E,tabIndex:0,role:"slider"}))}</span>)),</span>g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >return e.filter(Boolean).join(" ")}</span>,</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>r){var t=<span class="cstat-no" title="statement not covered" >r.color,</span>n=<span class="cstat-no" title="statement not covered" >r.left,</span>o=<span class="cstat-no" title="statement not covered" >r.top,</span>a=<span class="cstat-no" title="statement not covered" >void 0===o?.5:o,</span>l=<span class="cstat-no" title="statement not covered" >g(["react-colorful__pointer",r.className]);<span class="cstat-no" title="statement not covered" ></span>return react.createElement("div",{className:l,style:{top:100*a+"%",left:100*n+"%"}},react.createElement("div",{className:"react-colorful__pointer-fill",style:{backgroundColor:t}}))}</span>,</span>b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e,r,t){<span class="cstat-no" title="statement not covered" >return void 0===r&amp;&amp;(r=0),void 0===t&amp;&amp;(t=Math.pow(10,r)),Math.round(t*e)/t}</span>,</span>_=<span class="cstat-no" title="statement not covered" >{grad:.9,turn:360,rad:360/(2*Math.PI)},</span>x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >return L(C(e))}</span>,</span>C=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >return"#"===e[0]&amp;&amp;(e=e.substring(1)),e.length&lt;6?{r:parseInt(e[0]+e[0],16),g:parseInt(e[1]+e[1],16),b:parseInt(e[2]+e[2],16),a:4===e.length?b(parseInt(e[3]+e[3],16)/255,2):1}:{r:parseInt(e.substring(0,2),16),g:parseInt(e.substring(2,4),16),b:parseInt(e.substring(4,6),16),a:8===e.length?b(parseInt(e.substring(6,8),16)/255,2):1}}</span>,</span>E=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e,r){<span class="cstat-no" title="statement not covered" >return void 0===r&amp;&amp;(r="deg"),Number(e)*(_[r]||1)}</span>,</span>H=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >/hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e);<span class="cstat-no" title="statement not covered" ></span>return r?N({h:E(r[1],r[2]),s:Number(r[3]),l:Number(r[4]),a:void 0===r[5]?1:Number(r[5])/(r[6]?100:1)}):{h:0,s:0,v:0,a:1}}</span>,</span>N=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >e.s,</span>t=<span class="cstat-no" title="statement not covered" >e.l;<span class="cstat-no" title="statement not covered" ></span>return{h:e.h,s:(r*=(t&lt;50?t:100-t)/100)&gt;0?2*r/(t+r)*100:0,v:t+r,a:e.a}}</span>,</span>w=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >return K(I(e))}</span>,</span>y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >e.s,</span>t=<span class="cstat-no" title="statement not covered" >e.v,</span>n=<span class="cstat-no" title="statement not covered" >e.a,</span>o=<span class="cstat-no" title="statement not covered" >(200-r)*t/100;<span class="cstat-no" title="statement not covered" ></span>return{h:b(e.h),s:b(o&gt;0&amp;&amp;o&lt;200?r*t/100/(o&lt;=100?o:200-o)*100:0),l:b(o/2),a:b(n,2)}}</span>,</span>q=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >y(e);<span class="cstat-no" title="statement not covered" ></span>return"hsl("+r.h+", "+r.s+"%, "+r.l+"%)"}</span>,</span>k=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >y(e);<span class="cstat-no" title="statement not covered" ></span>return"hsla("+r.h+", "+r.s+"%, "+r.l+"%, "+r.a+")"}</span>,</span>I=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >e.h,</span>t=<span class="cstat-no" title="statement not covered" >e.s,</span>n=<span class="cstat-no" title="statement not covered" >e.v,</span>o=<span class="cstat-no" title="statement not covered" >e.a;<span class="cstat-no" title="statement not covered" ></span>r=r/360*6,t/=100,n/=100;v</span>ar a=<span class="cstat-no" title="statement not covered" >Math.floor(r),</span>l=<span class="cstat-no" title="statement not covered" >n*(1-t),</span>u=<span class="cstat-no" title="statement not covered" >n*(1-(r-a)*t),</span>c=<span class="cstat-no" title="statement not covered" >n*(1-(1-r+a)*t),</span>i=<span class="cstat-no" title="statement not covered" >a%6;<span class="cstat-no" title="statement not covered" ></span>return{r:b(255*[n,u,l,l,c,n][i]),g:b(255*[c,n,n,u,l,l][i]),b:b(255*[l,l,c,n,n,u][i]),a:b(o,2)}}</span>,</span>z=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >/rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e);<span class="cstat-no" title="statement not covered" ></span>return r?L({r:Number(r[1])/(r[2]?100/255:1),g:Number(r[3])/(r[4]?100/255:1),b:Number(r[5])/(r[6]?100/255:1),a:void 0===r[7]?1:Number(r[7])/(r[8]?100:1)}):{h:0,s:0,v:0,a:1}}</span>,</span>D=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >e.toString(16);<span class="cstat-no" title="statement not covered" ></span>return r.length&lt;2?"0"+r:r}</span>,</span>K=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >e.r,</span>t=<span class="cstat-no" title="statement not covered" >e.g,</span>n=<span class="cstat-no" title="statement not covered" >e.b,</span>o=<span class="cstat-no" title="statement not covered" >e.a,</span>a=<span class="cstat-no" title="statement not covered" >o&lt;1?D(b(255*o)):"";<span class="cstat-no" title="statement not covered" ></span>return"#"+D(r)+D(t)+D(n)+a}</span>,</span>L=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >e.r,</span>t=<span class="cstat-no" title="statement not covered" >e.g,</span>n=<span class="cstat-no" title="statement not covered" >e.b,</span>o=<span class="cstat-no" title="statement not covered" >e.a,</span>a=<span class="cstat-no" title="statement not covered" >Math.max(r,t,n),</span>l=<span class="cstat-no" title="statement not covered" >a-Math.min(r,t,n),</span>u=<span class="cstat-no" title="statement not covered" >l?a===r?(t-n)/l:a===t?2+(n-r)/l:4+(r-t)/l:0;<span class="cstat-no" title="statement not covered" ></span>return{h:b(60*(u&lt;0?u+6:u)),s:b(a?l/a*100:0),v:b(a/255*100),a:o}}</span>,</span>S=<span class="cstat-no" title="statement not covered" >react.memo((<span class="fstat-no" title="function not covered" >function(</span>r){var t=<span class="cstat-no" title="statement not covered" >r.hue,</span>n=<span class="cstat-no" title="statement not covered" >r.onChange,</span>o=<span class="cstat-no" title="statement not covered" >g(["react-colorful__hue",r.className]);<span class="cstat-no" title="statement not covered" ></span>return react.createElement("div",{className:o},react.createElement(m,{onMove:<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >n({h:360*e.left})}</span>,onKey:<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >n({h:s(t+360*e.left,0,360)})}</span>,"aria-label":"Hue","aria-valuenow":b(t),"aria-valuemax":"360","aria-valuemin":"0"},react.createElement(p,{className:"react-colorful__hue-pointer",left:t/360,color:q({h:t,s:100,v:100,a:1})})))}</span>)),</span>T=<span class="cstat-no" title="statement not covered" >react.memo((<span class="fstat-no" title="function not covered" >function(</span>r){var t=<span class="cstat-no" title="statement not covered" >r.hsva,</span>n=<span class="cstat-no" title="statement not covered" >r.onChange,</span>o=<span class="cstat-no" title="statement not covered" >{backgroundColor:q({h:t.h,s:100,v:100,a:1})};<span class="cstat-no" title="statement not covered" ></span>return react.createElement("div",{className:"react-colorful__saturation",style:o},react.createElement(m,{onMove:<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >n({s:100*e.left,v:100-100*e.top})}</span>,onKey:<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >n({s:s(t.s+100*e.left,0,100),v:s(t.v-100*e.top,0,100)})}</span>,"aria-label":"Color","aria-valuetext":"Saturation "+b(t.s)+"%, Brightness "+b(t.v)+"%"},react.createElement(p,{className:"react-colorful__saturation-pointer",top:1-t.v/100,left:t.s/100,color:q(t)})))}</span>)),</span>F=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e,r){<span class="cstat-no" title="statement not covered" >if(e===r)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var t in e)<span class="cstat-no" title="statement not covered" >if(e[t]!==r[t])<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,</span>P=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e,r){<span class="cstat-no" title="statement not covered" >return e.replace(/\s/g,"")===r.replace(/\s/g,"")}</span>,</span>X=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e,r){<span class="cstat-no" title="statement not covered" >return e.toLowerCase()===r.toLowerCase()||F(C(e),C(r))}</span>;</span>function <span class="fstat-no" title="function not covered" >Y(</span>e,t,l){var u=<span class="cstat-no" title="statement not covered" >i(l),</span>c=<span class="cstat-no" title="statement not covered" >(0,react.useState)((<span class="fstat-no" title="function not covered" >function(</span>){<span class="cstat-no" title="statement not covered" >return e.toHsva(t)}</span>)),</span>s=<span class="cstat-no" title="statement not covered" >c[0],</span>f=<span class="cstat-no" title="statement not covered" >c[1],</span>v=<span class="cstat-no" title="statement not covered" >(0,react.useRef)({color:t,hsva:s});<span class="cstat-no" title="statement not covered" ></span>(0,react.useEffect)((<span class="fstat-no" title="function not covered" >function(</span>){<span class="cstat-no" title="statement not covered" >if(!e.equal(t,v.current.color)){var r=<span class="cstat-no" title="statement not covered" >e.toHsva(t);<span class="cstat-no" title="statement not covered" ></span>v.current={hsva:r,color:t},f(r)}</span>}</span>),[t,e]),(0,react.useEffect)((<span class="fstat-no" title="function not covered" >function(</span>){var r;<span class="cstat-no" title="statement not covered" >F(s,v.current.hsva)||e.equal(r=e.fromHsva(s),v.current.color)||(v.current={hsva:s,color:r},u(r))}</span>),[s,e,u]);v</span>ar d=<span class="cstat-no" title="statement not covered" >(0,react.useCallback)((<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >f((<span class="fstat-no" title="function not covered" >function(</span>r){<span class="cstat-no" title="statement not covered" >return Object.assign({},r,e)}</span>))}</span>),[]);<span class="cstat-no" title="statement not covered" ></span>return[s,d]}</span>var R,ColorSpace2,V=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof window?react.useLayoutEffect:react.useEffect,</span>J=<span class="cstat-no" title="statement not covered" >new Map,</span>Q=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >V((<span class="fstat-no" title="function not covered" >function(</span>){var r=<span class="cstat-no" title="statement not covered" >e.current?e.current.ownerDocument:document;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==r&amp;&amp;!J.has(r)){var t=<span class="cstat-no" title="statement not covered" >r.createElement("style");<span class="cstat-no" title="statement not covered" ></span>t.innerHTML='.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url(\'data:image/svg+xml;charset=utf-8,&lt;svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"&gt;&lt;path d="M8 0h8v8H8zM0 8h8v8H0z"/&gt;&lt;/svg&gt;\')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}',J.set(r,t);v</span>ar n=<span class="cstat-no" title="statement not covered" >R||__webpack_require__.nc;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;t.setAttribute("nonce",n),r.head.appendChild(t)}</span>}</span>),[])}</span>,</span>U=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){var n=<span class="cstat-no" title="statement not covered" >t.className,</span>o=<span class="cstat-no" title="statement not covered" >t.colorModel,</span>a=<span class="cstat-no" title="statement not covered" >t.color,</span>l=<span class="cstat-no" title="statement not covered" >void 0===a?o.defaultColor:a,</span>i=<span class="cstat-no" title="statement not covered" >t.onChange,</span>s=<span class="cstat-no" title="statement not covered" >c(t,["className","colorModel","color","onChange"]),</span>f=<span class="cstat-no" title="statement not covered" >(0,react.useRef)(null);<span class="cstat-no" title="statement not covered" ></span>Q(f);v</span>ar v=<span class="cstat-no" title="statement not covered" >Y(o,l,i),</span>d=<span class="cstat-no" title="statement not covered" >v[0],</span>h=<span class="cstat-no" title="statement not covered" >v[1],</span>m=<span class="cstat-no" title="statement not covered" >g(["react-colorful",n]);<span class="cstat-no" title="statement not covered" ></span>return react.createElement("div",u({},s,{ref:f,className:m}),react.createElement(T,{hsva:d,onChange:h}),react.createElement(S,{hue:d.h,onChange:h,className:"react-colorful__last-control"}))}</span>,</span>W=<span class="cstat-no" title="statement not covered" >{defaultColor:"000",toHsva:x,fromHsva:<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >return w({h:e.h,s:e.s,v:e.v,a:1})}</span>,equal:X},</span>ee=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>r){var t=<span class="cstat-no" title="statement not covered" >r.className,</span>n=<span class="cstat-no" title="statement not covered" >r.hsva,</span>o=<span class="cstat-no" title="statement not covered" >r.onChange,</span>a=<span class="cstat-no" title="statement not covered" >{backgroundImage:"linear-gradient(90deg, "+k(Object.assign({},n,{a:0}))+", "+k(Object.assign({},n,{a:1}))+")"},</span>l=<span class="cstat-no" title="statement not covered" >g(["react-colorful__alpha",t]),</span>u=<span class="cstat-no" title="statement not covered" >b(100*n.a);<span class="cstat-no" title="statement not covered" ></span>return react.createElement("div",{className:l},react.createElement("div",{className:"react-colorful__alpha-gradient",style:a}),react.createElement(m,{onMove:<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >o({a:e.left})}</span>,onKey:<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >o({a:s(n.a+e.left)})}</span>,"aria-label":"Alpha","aria-valuetext":u+"%","aria-valuenow":u,"aria-valuemin":"0","aria-valuemax":"100"},react.createElement(p,{className:"react-colorful__alpha-pointer",left:n.a,color:k(n)})))}</span>,</span>re=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){var n=<span class="cstat-no" title="statement not covered" >t.className,</span>o=<span class="cstat-no" title="statement not covered" >t.colorModel,</span>a=<span class="cstat-no" title="statement not covered" >t.color,</span>l=<span class="cstat-no" title="statement not covered" >void 0===a?o.defaultColor:a,</span>i=<span class="cstat-no" title="statement not covered" >t.onChange,</span>s=<span class="cstat-no" title="statement not covered" >c(t,["className","colorModel","color","onChange"]),</span>f=<span class="cstat-no" title="statement not covered" >(0,react.useRef)(null);<span class="cstat-no" title="statement not covered" ></span>Q(f);v</span>ar v=<span class="cstat-no" title="statement not covered" >Y(o,l,i),</span>d=<span class="cstat-no" title="statement not covered" >v[0],</span>h=<span class="cstat-no" title="statement not covered" >v[1],</span>m=<span class="cstat-no" title="statement not covered" >g(["react-colorful",n]);<span class="cstat-no" title="statement not covered" ></span>return react.createElement("div",u({},s,{ref:f,className:m}),react.createElement(T,{hsva:d,onChange:h}),react.createElement(S,{hue:d.h,onChange:h}),react.createElement(ee,{hsva:d,onChange:h,className:"react-colorful__last-control"}))}</span>,</span>le=<span class="cstat-no" title="statement not covered" >{defaultColor:"hsla(0, 0%, 0%, 1)",toHsva:H,fromHsva:k,equal:P},</span>Ee=<span class="cstat-no" title="statement not covered" >{defaultColor:"rgba(0, 0, 0, 1)",toHsva:z,fromHsva:<span class="fstat-no" title="function not covered" >function(</span>e){var r=<span class="cstat-no" title="statement not covered" >I(e);<span class="cstat-no" title="statement not covered" ></span>return"rgba("+r.r+", "+r.g+", "+r.b+", "+r.a+")"}</span>,equal:P},</span>Wrapper=<span class="cstat-no" title="statement not covered" >theming.I4.div({position:"relative",maxWidth:250,'&amp;[aria-readonly="true"]':{opacity:.5}}),</span>PickerTooltip=<span class="cstat-no" title="statement not covered" >(0,theming.I4)(components.kR)({position:"absolute",zIndex:1,top:4,left:4,"[aria-readonly=true] &amp;":{cursor:"not-allowed"}}),</span>TooltipContent=<span class="cstat-no" title="statement not covered" >theming.I4.div({width:200,margin:5,".react-colorful__saturation":{borderRadius:"4px 4px 0 0"},".react-colorful__hue":{boxShadow:"inset 0 0 0 1px rgb(0 0 0 / 5%)"},".react-colorful__last-control":{borderRadius:"0 0 4px 4px"}}),</span>Note=<span class="cstat-no" title="statement not covered" >(0,theming.I4)(components._)((<span class="fstat-no" title="function not covered" >({</span>theme})=&gt;(<span class="cstat-no" title="statement not covered" >{fontFamily:theme.typography.fonts.base})</span>)),</span>Swatches=<span class="cstat-no" title="statement not covered" >theming.I4.div({display:"grid",gridTemplateColumns:"repeat(9, 16px)",gap:6,padding:3,marginTop:5,width:200}),</span>SwatchColor=<span class="cstat-no" title="statement not covered" >theming.I4.div((<span class="fstat-no" title="function not covered" >({</span>theme,active})=&gt;(<span class="cstat-no" title="statement not covered" >{width:16,height:16,boxShadow:active?`${theme.appBorderColor} 0 0 0 1px inset, ${theme.textMutedColor}50 0 0 0 4px`:`${theme.appBorderColor} 0 0 0 1px inset`,borderRadius:theme.appBorderRadius})</span>)),</span>Swatch=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>value,style,...props})=&gt;{let backgroundImage=<span class="cstat-no" title="statement not covered" >`linear-gradient(${value}, ${value}), url('data:image/svg+xml;charset=utf-8,&lt;svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"&gt;&lt;path d="M8 0h8v8H8zM0 8h8v8H0z"/&gt;&lt;/svg&gt;'), linear-gradient(#fff, #fff)`;<span class="cstat-no" title="statement not covered" ></span>return react.createElement(SwatchColor,{...props,style:{...style,backgroundImage}})}</span>,</span>Input=<span class="cstat-no" title="statement not covered" >(0,theming.I4)(components.lV.Input)((<span class="fstat-no" title="function not covered" >({</span>theme,readOnly})=&gt;(<span class="cstat-no" title="statement not covered" >{width:"100%",paddingLeft:30,paddingRight:30,boxSizing:"border-box",fontFamily:theme.typography.fonts.base})</span>)),</span>ToggleIcon=<span class="cstat-no" title="statement not covered" >(0,theming.I4)(dist.QDE)((<span class="fstat-no" title="function not covered" >({</span>theme})=&gt;(<span class="cstat-no" title="statement not covered" >{position:"absolute",zIndex:1,top:6,right:7,width:20,height:20,padding:4,boxSizing:"border-box",cursor:"pointer",color:theme.input.color})</span>)),</span>ColorSpace=(<span class="cstat-no" title="statement not covered" >(ColorSpace2=ColorSpace||{}).RGB="rgb",ColorSpace2.HSL="hsl",ColorSpace2.HEX="hex",ColorSpace2)</span>,COLOR_SPACES=<span class="cstat-no" title="statement not covered" >Object.values(ColorSpace),</span>COLOR_REGEXP=<span class="cstat-no" title="statement not covered" >/\(([0-9]+),\s*([0-9]+)%?,\s*([0-9]+)%?,?\s*([0-9.]+)?\)/,</span>RGB_REGEXP=<span class="cstat-no" title="statement not covered" >/^\s*rgba?\(([0-9]+),\s*([0-9]+),\s*([0-9]+),?\s*([0-9.]+)?\)\s*$/i,</span>HSL_REGEXP=<span class="cstat-no" title="statement not covered" >/^\s*hsla?\(([0-9]+),\s*([0-9]+)%,\s*([0-9]+)%,?\s*([0-9.]+)?\)\s*$/i,</span>HEX_REGEXP=<span class="cstat-no" title="statement not covered" >/^\s*#?([0-9a-f]{3}|[0-9a-f]{6})\s*$/i,</span>SHORTHEX_REGEXP=<span class="cstat-no" title="statement not covered" >/^\s*#?([0-9a-f]{3})\s*$/i,</span>ColorPicker=<span class="cstat-no" title="statement not covered" >{hex:<span class="fstat-no" title="function not covered" >function(</span>r){<span class="cstat-no" title="statement not covered" >return react.createElement(U,u({},r,{colorModel:W}))}</span>,rgb:<span class="fstat-no" title="function not covered" >function(</span>r){<span class="cstat-no" title="statement not covered" >return react.createElement(re,u({},r,{colorModel:Ee}))}</span>,hsl:<span class="fstat-no" title="function not covered" >function(</span>r){<span class="cstat-no" title="statement not covered" >return react.createElement(re,u({},r,{colorModel:le}))}</span>},</span>fallbackColor=<span class="cstat-no" title="statement not covered" >{hex:"transparent",rgb:"rgba(0, 0, 0, 0)",hsl:"hsla(0, 0%, 0%, 0)"},</span>stringToArgs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >value=</span>&gt;{let match=<span class="cstat-no" title="statement not covered" >value?.match(COLOR_REGEXP);<span class="cstat-no" title="statement not covered" ></span>if(!match)<span class="cstat-no" title="statement not covered" >return[0,0,0,1];l</span></span>et[,x,y,z,a=<span class="branch-0 cbranch-no" title="branch not covered" >1]</span>=<span class="cstat-no" title="statement not covered" >match;<span class="cstat-no" title="statement not covered" ></span>return[x,y,z,a].map(Number)}</span>,</span>parseValue=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >value=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!value)<span class="cstat-no" title="statement not covered" >return;l</span></span>et valid=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>if(RGB_REGEXP.test(value)){let[r,g,b,a]=<span class="cstat-no" title="statement not covered" >stringToArgs(value),</span>[h,s,l]=<span class="cstat-no" title="statement not covered" >color_convert_default().rgb.hsl([r,g,b])||[0,0,0];<span class="cstat-no" title="statement not covered" ></span>return{valid,value,keyword:color_convert_default().rgb.keyword([r,g,b]),colorSpace:"rgb",rgb:value,hsl:`hsla(${h}, ${s}%, ${l}%, ${a})`,hex:`#${color_convert_default().rgb.hex([r,g,b]).toLowerCase()}`}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(HSL_REGEXP.test(value)){let[h,s,l,a]=<span class="cstat-no" title="statement not covered" >stringToArgs(value),</span>[r,g,b]=<span class="cstat-no" title="statement not covered" >color_convert_default().hsl.rgb([h,s,l])||[0,0,0];<span class="cstat-no" title="statement not covered" ></span>return{valid,value,keyword:color_convert_default().hsl.keyword([h,s,l]),colorSpace:"hsl",rgb:`rgba(${r}, ${g}, ${b}, ${a})`,hsl:value,hex:`#${color_convert_default().hsl.hex([h,s,l]).toLowerCase()}`}}</span>l</span>et plain=<span class="cstat-no" title="statement not covered" >value.replace("#",""),</span>rgb=<span class="cstat-no" title="statement not covered" >color_convert_default().keyword.rgb(plain)||color_convert_default().hex.rgb(plain),</span>hsl=<span class="cstat-no" title="statement not covered" >color_convert_default().rgb.hsl(rgb),</span>mapped=<span class="cstat-no" title="statement not covered" >value;<span class="cstat-no" title="statement not covered" ></span>if(/[^#a-f0-9]/i.test(value)?mapped=plain:HEX_REGEXP.test(value)&amp;&amp;(mapped=`#${plain}`),mapped.startsWith("#"))<span class="cstat-no" title="statement not covered" >valid=HEX_REGEXP.test(mapped);e</span>lse <span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >color_convert_default().keyword.hex(mapped)}</span>catch{<span class="cstat-no" title="statement not covered" >valid=!1}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn{valid,value:mapped,keyword:color_convert_default().rgb.keyword(rgb),colorSpace:"hex",rgb:`rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 1)`,hsl:`hsla(${hsl[0]}, ${hsl[1]}%, ${hsl[2]}%, 1)`,hex:mapped}}</span>,</span>useColorInput=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>nitialValue,onChange)=&gt;{let[value,setValue]=<span class="cstat-no" title="statement not covered" >(0,react.useState)(initialValue||""),</span>[color,setColor]=<span class="cstat-no" title="statement not covered" >(0,react.useState)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >parseValue(value))</span>),</span>[colorSpace,setColorSpace]=<span class="cstat-no" title="statement not covered" >(0,react.useState)(color?.colorSpace||"hex");<span class="cstat-no" title="statement not covered" ></span>(0,react.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{let nextValue=<span class="cstat-no" title="statement not covered" >initialValue||"",</span>nextColor=<span class="cstat-no" title="statement not covered" >parseValue(nextValue);<span class="cstat-no" title="statement not covered" ></span>setValue(nextValue),setColor(nextColor),setColorSpace(nextColor?.colorSpace||"hex")}</span>),[initialValue]);l</span>et realValue=<span class="cstat-no" title="statement not covered" >(0,react.useMemo)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >(v</span>alue,color,colorSpace)=&gt;{<span class="cstat-no" title="statement not covered" >if(!value||!color?.valid)<span class="cstat-no" title="statement not covered" >return fallbackColor[colorSpace];<span class="cstat-no" title="statement not covered" >i</span></span>f("hex"!==colorSpace)<span class="cstat-no" title="statement not covered" >return color?.[colorSpace]||fallbackColor[colorSpace];<span class="cstat-no" title="statement not covered" >i</span></span>f(!color.hex.startsWith("#"))<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return`#${color_convert_default().keyword.hex(color.hex)}`}</span>catch{<span class="cstat-no" title="statement not covered" >return fallbackColor.hex}</span>l</span></span>et short=<span class="cstat-no" title="statement not covered" >color.hex.match(SHORTHEX_REGEXP);<span class="cstat-no" title="statement not covered" ></span>if(!short)<span class="cstat-no" title="statement not covered" >return HEX_REGEXP.test(color.hex)?color.hex:fallbackColor.hex;l</span></span>et[r,g,b]=<span class="cstat-no" title="statement not covered" >short[1].split("");<span class="cstat-no" title="statement not covered" ></span>return`#${r}${r}${g}${g}${b}${b}`}</span>)(value,color,colorSpace).toLowerCase())</span>,[value,color,colorSpace]),</span>updateValue=<span class="cstat-no" title="statement not covered" >(0,react.useCallback)((<span class="fstat-no" title="function not covered" >update=</span>&gt;{let parsed=<span class="cstat-no" title="statement not covered" >parseValue(update),</span>v=<span class="cstat-no" title="statement not covered" >parsed?.value||update||"";<span class="cstat-no" title="statement not covered" ></span>setValue(v),""===v&amp;&amp;(setColor(void 0),onChange(void 0)),parsed&amp;&amp;(setColor(parsed),setColorSpace(parsed.colorSpace),onChange(parsed.value))}</span>),[onChange]),</span>cycleColorSpace=<span class="cstat-no" title="statement not covered" >(0,react.useCallback)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{let next=<span class="cstat-no" title="statement not covered" >COLOR_SPACES.indexOf(colorSpace)+1;<span class="cstat-no" title="statement not covered" ></span>next&gt;=COLOR_SPACES.length&amp;&amp;(next=0),setColorSpace(COLOR_SPACES[next]);l</span>et update=<span class="cstat-no" title="statement not covered" >color?.[COLOR_SPACES[next]]||"";<span class="cstat-no" title="statement not covered" ></span>setValue(update),onChange(update)}</span>),[color,colorSpace,onChange]);<span class="cstat-no" title="statement not covered" ></span>return{value,realValue,updateValue,color,colorSpace,cycleColorSpace}}</span>,</span>id=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >value=</span>&gt;<span class="cstat-no" title="statement not covered" >value.replace(/\s*/,"").toLowerCase(),</span></span>ColorControl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>name,value:initialValue,onChange,onFocus,onBlur,presetColors,startOpen=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>argType})=&gt;{let debouncedOnChange=<span class="cstat-no" title="statement not covered" >(0,react.useCallback)(debounce_default()(onChange,200),[onChange]),</span>{value,realValue,updateValue,color,colorSpace,cycleColorSpace}=<span class="cstat-no" title="statement not covered" >useColorInput(initialValue,debouncedOnChange),</span>{presets,addPreset}=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >(p</span>resetColors,currentColor,colorSpace)=&gt;{let[selectedColors,setSelectedColors]=<span class="cstat-no" title="statement not covered" >(0,react.useState)(currentColor?.valid?[currentColor]:[]);<span class="cstat-no" title="statement not covered" ></span>(0,react.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >void 0===currentColor&amp;&amp;setSelectedColors([])}</span>),[currentColor]);l</span>et presets=<span class="cstat-no" title="statement not covered" >(0,react.useMemo)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >(presetColors||[]).map((<span class="fstat-no" title="function not covered" >preset=</span>&gt;<span class="cstat-no" title="statement not covered" >"string"==typeof preset?parseValue(preset):preset.title?{...parseValue(preset.color),keyword:preset.title}:parseValue(preset.color))</span>).concat(selectedColors).filter(Boolean).slice(-27))</span>,[presetColors,selectedColors]),</span>addPreset=<span class="cstat-no" title="statement not covered" >(0,react.useCallback)((<span class="fstat-no" title="function not covered" >color=</span>&gt;{<span class="cstat-no" title="statement not covered" >color?.valid&amp;&amp;(presets.some((<span class="fstat-no" title="function not covered" >preset=</span>&gt;<span class="cstat-no" title="statement not covered" >id(preset[colorSpace])===id(color[colorSpace]))</span>)||setSelectedColors((<span class="fstat-no" title="function not covered" >arr=</span>&gt;<span class="cstat-no" title="statement not covered" >arr.concat(color))</span>))}</span>),[colorSpace,presets]);<span class="cstat-no" title="statement not covered" ></span>return{presets,addPreset}}</span>)(presetColors,color,colorSpace),</span>Picker=<span class="cstat-no" title="statement not covered" >ColorPicker[colorSpace],</span>readonly=<span class="cstat-no" title="statement not covered" >!!argType?.table?.readonly;<span class="cstat-no" title="statement not covered" ></span>return react.createElement(Wrapper,{"aria-readonly":readonly},react.createElement(PickerTooltip,{startOpen,trigger:readonly?[null]:void 0,closeOnOutsideClick:!0,onVisibleChange:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >addPreset(color),</span>tooltip:react.createElement(TooltipContent,null,react.createElement(Picker,{color:"transparent"===realValue?"#000000":realValue,onChange:updateValue,onFocus,onBlur}),presets.length&gt;0&amp;&amp;react.createElement(Swatches,null,presets.map((<span class="fstat-no" title="function not covered" >(p</span>reset,index)=&gt;<span class="cstat-no" title="statement not covered" >react.createElement(components.kR,{key:`${preset.value}-${index}`,hasChrome:!1,tooltip:react.createElement(Note,{note:preset.keyword||preset.value})},react.createElement(Swatch,{value:preset[colorSpace],active:color&amp;&amp;id(preset[colorSpace])===id(color[colorSpace]),onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >updateValue(preset.value)}</span>)))</span>)))},react.createElement(Swatch,{value:realValue,style:{margin:4}})),react.createElement(Input,{id:(0,chunk_MKV36LKP.ZA)(name),value,onChange:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >updateValue(e.target.value),</span>onFocus:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.target.select(),</span>readOnly:readonly,placeholder:"Choose color..."}),value?react.createElement(ToggleIcon,{onClick:cycleColorSpace}):null)}</span>,</span>Color_default=<span class="cstat-no" title="statement not covered" >ColorControl}</span>,"./node_modules/color-convert/conversions.js":<span class="fstat-no" title="function not covered" >(m</span>odule,__unused_webpack_exports,__webpack_require__)=&gt;{const cssKeywords=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/color-name/index.js"),</span>reverseKeywords=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const key of Object.keys(cssKeywords))<span class="cstat-no" title="statement not covered" >reverseKeywords[cssKeywords[key]]=key;c</span></span>onst convert=<span class="cstat-no" title="statement not covered" >{rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};<span class="cstat-no" title="statement not covered" ></span>module.exports=convert;<span class="cstat-no" title="statement not covered" >f</span>or(const model of Object.keys(convert)){<span class="cstat-no" title="statement not covered" >if(!("channels"in convert[model]))<span class="cstat-no" title="statement not covered" >throw new Error("missing channels property: "+model);<span class="cstat-no" title="statement not covered" >i</span></span>f(!("labels"in convert[model]))<span class="cstat-no" title="statement not covered" >throw new Error("missing channel labels property: "+model);<span class="cstat-no" title="statement not covered" >i</span></span>f(convert[model].labels.length!==convert[model].channels)<span class="cstat-no" title="statement not covered" >throw new Error("channel and label counts mismatch: "+model);c</span></span>onst{channels,labels}=<span class="cstat-no" title="statement not covered" >convert[model];<span class="cstat-no" title="statement not covered" ></span>delete convert[model].channels,delete convert[model].labels,Object.defineProperty(convert[model],"channels",{value:channels}),Object.defineProperty(convert[model],"labels",{value:labels})}<span class="cstat-no" title="statement not covered" ></span>c</span>onvert.rgb.hsl=<span class="fstat-no" title="function not covered" >function(</span>rgb){const r=<span class="cstat-no" title="statement not covered" >rgb[0]/255,</span>g=<span class="cstat-no" title="statement not covered" >rgb[1]/255,</span>b=<span class="cstat-no" title="statement not covered" >rgb[2]/255,</span>min=<span class="cstat-no" title="statement not covered" >Math.min(r,g,b),</span>max=<span class="cstat-no" title="statement not covered" >Math.max(r,g,b),</span>delta=<span class="cstat-no" title="statement not covered" >max-min;</span>let h,s;<span class="cstat-no" title="statement not covered" >max===min?h=0:r===max?h=(g-b)/delta:g===max?h=2+(b-r)/delta:b===max&amp;&amp;(h=4+(r-g)/delta),h=Math.min(60*h,360),h&lt;0&amp;&amp;(h+=360);c</span>onst l=<span class="cstat-no" title="statement not covered" >(min+max)/2;<span class="cstat-no" title="statement not covered" ></span>return s=max===min?0:l&lt;=.5?delta/(max+min):delta/(2-max-min),[h,100*s,100*l]}</span>,convert.rgb.hsv=<span class="fstat-no" title="function not covered" >function(</span>rgb){let rdif,gdif,bdif,h,s;const r=<span class="cstat-no" title="statement not covered" >rgb[0]/255,</span>g=<span class="cstat-no" title="statement not covered" >rgb[1]/255,</span>b=<span class="cstat-no" title="statement not covered" >rgb[2]/255,</span>v=<span class="cstat-no" title="statement not covered" >Math.max(r,g,b),</span>diff=<span class="cstat-no" title="statement not covered" >v-Math.min(r,g,b),</span>diffc=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>c){<span class="cstat-no" title="statement not covered" >return(v-c)/6/diff+.5}</span>;<span class="cstat-no" title="statement not covered" ></span>return 0===diff?(h=0,s=0):(s=diff/v,rdif=diffc(r),gdif=diffc(g),bdif=diffc(b),r===v?h=bdif-gdif:g===v?h=1/3+rdif-bdif:b===v&amp;&amp;(h=2/3+gdif-rdif),h&lt;0?h+=1:h&gt;1&amp;&amp;(h-=1)),[360*h,100*s,100*v]}</span>,convert.rgb.hwb=<span class="fstat-no" title="function not covered" >function(</span>rgb){const r=<span class="cstat-no" title="statement not covered" >rgb[0],</span>g=<span class="cstat-no" title="statement not covered" >rgb[1];</span>let b=<span class="cstat-no" title="statement not covered" >rgb[2];</span>const h=<span class="cstat-no" title="statement not covered" >convert.rgb.hsl(rgb)[0],</span>w=<span class="cstat-no" title="statement not covered" >1/255*Math.min(r,Math.min(g,b));<span class="cstat-no" title="statement not covered" ></span>return b=1-1/255*Math.max(r,Math.max(g,b)),[h,100*w,100*b]}</span>,convert.rgb.cmyk=<span class="fstat-no" title="function not covered" >function(</span>rgb){const r=<span class="cstat-no" title="statement not covered" >rgb[0]/255,</span>g=<span class="cstat-no" title="statement not covered" >rgb[1]/255,</span>b=<span class="cstat-no" title="statement not covered" >rgb[2]/255,</span>k=<span class="cstat-no" title="statement not covered" >Math.min(1-r,1-g,1-b);<span class="cstat-no" title="statement not covered" ></span>return[100*((1-r-k)/(1-k)||0),100*((1-g-k)/(1-k)||0),100*((1-b-k)/(1-k)||0),100*k]}</span>,convert.rgb.keyword=<span class="fstat-no" title="function not covered" >function(</span>rgb){const reversed=<span class="cstat-no" title="statement not covered" >reverseKeywords[rgb];<span class="cstat-no" title="statement not covered" ></span>if(reversed)<span class="cstat-no" title="statement not covered" >return reversed;l</span></span>et currentClosestKeyword,currentClosestDistance=<span class="cstat-no" title="statement not covered" >1/0;<span class="cstat-no" title="statement not covered" ></span>for(const keyword of Object.keys(cssKeywords)){const value=<span class="cstat-no" title="statement not covered" >cssKeywords[keyword],</span>distance=(<span class="cstat-no" title="statement not covered" >y=value,((x=rgb)[0]-y[0])**2+(x[1]-y[1])**2+(x[2]-y[2])**2)</span>;<span class="cstat-no" title="statement not covered" >distance&lt;currentClosestDistance&amp;&amp;(currentClosestDistance=distance,currentClosestKeyword=keyword)}</span>v</span>ar x,y;<span class="cstat-no" title="statement not covered" >return currentClosestKeyword}</span>,convert.keyword.rgb=<span class="fstat-no" title="function not covered" >function(</span>keyword){<span class="cstat-no" title="statement not covered" >return cssKeywords[keyword]}</span>,convert.rgb.xyz=<span class="fstat-no" title="function not covered" >function(</span>rgb){let r=<span class="cstat-no" title="statement not covered" >rgb[0]/255,</span>g=<span class="cstat-no" title="statement not covered" >rgb[1]/255,</span>b=<span class="cstat-no" title="statement not covered" >rgb[2]/255;<span class="cstat-no" title="statement not covered" ></span>r=r&gt;.04045?((r+.055)/1.055)**2.4:r/12.92,g=g&gt;.04045?((g+.055)/1.055)**2.4:g/12.92,b=b&gt;.04045?((b+.055)/1.055)**2.4:b/12.92;<span class="cstat-no" title="statement not covered" >r</span>eturn[100*(.4124*r+.3576*g+.1805*b),100*(.2126*r+.7152*g+.0722*b),100*(.0193*r+.1192*g+.9505*b)]}</span>,convert.rgb.lab=<span class="fstat-no" title="function not covered" >function(</span>rgb){const xyz=<span class="cstat-no" title="statement not covered" >convert.rgb.xyz(rgb);</span>let x=<span class="cstat-no" title="statement not covered" >xyz[0],</span>y=<span class="cstat-no" title="statement not covered" >xyz[1],</span>z=<span class="cstat-no" title="statement not covered" >xyz[2];<span class="cstat-no" title="statement not covered" ></span>x/=95.047,y/=100,z/=108.883,x=x&gt;.008856?x**(1/3):7.787*x+16/116,y=y&gt;.008856?y**(1/3):7.787*y+16/116,z=z&gt;.008856?z**(1/3):7.787*z+16/116;<span class="cstat-no" title="statement not covered" >r</span>eturn[116*y-16,500*(x-y),200*(y-z)]}</span>,convert.hsl.rgb=<span class="fstat-no" title="function not covered" >function(</span>hsl){const h=<span class="cstat-no" title="statement not covered" >hsl[0]/360,</span>s=<span class="cstat-no" title="statement not covered" >hsl[1]/100,</span>l=<span class="cstat-no" title="statement not covered" >hsl[2]/100;</span>let t2,t3,val;<span class="cstat-no" title="statement not covered" >if(0===s)<span class="cstat-no" title="statement not covered" >return val=255*l,[val,val,val];<span class="cstat-no" title="statement not covered" >t</span></span>2=l&lt;.5?l*(1+s):l+s-l*s;c</span>onst t1=<span class="cstat-no" title="statement not covered" >2*l-t2,</span>rgb=<span class="cstat-no" title="statement not covered" >[0,0,0];<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;3;i++)<span class="cstat-no" title="statement not covered" >t3=h+1/3*-(i-1),t3&lt;0&amp;&amp;t3++,t3&gt;1&amp;&amp;t3--,val=6*t3&lt;1?t1+6*(t2-t1)*t3:2*t3&lt;1?t2:3*t3&lt;2?t1+(t2-t1)*(2/3-t3)*6:t1,rgb[i]=255*val;<span class="cstat-no" title="statement not covered" >r</span></span>eturn rgb}</span>,convert.hsl.hsv=<span class="fstat-no" title="function not covered" >function(</span>hsl){const h=<span class="cstat-no" title="statement not covered" >hsl[0];</span>let s=<span class="cstat-no" title="statement not covered" >hsl[1]/100,</span>l=<span class="cstat-no" title="statement not covered" >hsl[2]/100,</span>smin=<span class="cstat-no" title="statement not covered" >s;</span>const lmin=<span class="cstat-no" title="statement not covered" >Math.max(l,.01);<span class="cstat-no" title="statement not covered" ></span>l*=2,s*=l&lt;=1?l:2-l,smin*=lmin&lt;=1?lmin:2-lmin;<span class="cstat-no" title="statement not covered" >r</span>eturn[h,100*(0===l?2*smin/(lmin+smin):2*s/(l+s)),100*((l+s)/2)]}</span>,convert.hsv.rgb=<span class="fstat-no" title="function not covered" >function(</span>hsv){const h=<span class="cstat-no" title="statement not covered" >hsv[0]/60,</span>s=<span class="cstat-no" title="statement not covered" >hsv[1]/100;</span>let v=<span class="cstat-no" title="statement not covered" >hsv[2]/100;</span>const hi=<span class="cstat-no" title="statement not covered" >Math.floor(h)%6,</span>f=<span class="cstat-no" title="statement not covered" >h-Math.floor(h),</span>p=<span class="cstat-no" title="statement not covered" >255*v*(1-s),</span>q=<span class="cstat-no" title="statement not covered" >255*v*(1-s*f),</span>t=<span class="cstat-no" title="statement not covered" >255*v*(1-s*(1-f));<span class="cstat-no" title="statement not covered" ></span>switch(v*=255,hi){case 0:<span class="cstat-no" title="statement not covered" >return[v,t,p];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return[q,v,p];c</span>ase 2:<span class="cstat-no" title="statement not covered" >return[p,v,t];c</span>ase 3:<span class="cstat-no" title="statement not covered" >return[p,q,v];c</span>ase 4:<span class="cstat-no" title="statement not covered" >return[t,p,v];c</span>ase 5:<span class="cstat-no" title="statement not covered" >return[v,p,q]}</span>}</span>,convert.hsv.hsl=<span class="fstat-no" title="function not covered" >function(</span>hsv){const h=<span class="cstat-no" title="statement not covered" >hsv[0],</span>s=<span class="cstat-no" title="statement not covered" >hsv[1]/100,</span>v=<span class="cstat-no" title="statement not covered" >hsv[2]/100,</span>vmin=<span class="cstat-no" title="statement not covered" >Math.max(v,.01);</span>let sl,l;<span class="cstat-no" title="statement not covered" >l=(2-s)*v;c</span>onst lmin=<span class="cstat-no" title="statement not covered" >(2-s)*vmin;<span class="cstat-no" title="statement not covered" ></span>return sl=s*vmin,sl/=lmin&lt;=1?lmin:2-lmin,sl=sl||0,l/=2,[h,100*sl,100*l]}</span>,convert.hwb.rgb=<span class="fstat-no" title="function not covered" >function(</span>hwb){const h=<span class="cstat-no" title="statement not covered" >hwb[0]/360;</span>let wh=<span class="cstat-no" title="statement not covered" >hwb[1]/100,</span>bl=<span class="cstat-no" title="statement not covered" >hwb[2]/100;</span>const ratio=<span class="cstat-no" title="statement not covered" >wh+bl;</span>let f;<span class="cstat-no" title="statement not covered" >ratio&gt;1&amp;&amp;(wh/=ratio,bl/=ratio);c</span>onst i=<span class="cstat-no" title="statement not covered" >Math.floor(6*h),</span>v=<span class="cstat-no" title="statement not covered" >1-bl;<span class="cstat-no" title="statement not covered" ></span>f=6*h-i,1&amp;i&amp;&amp;(f=1-f);c</span>onst n=<span class="cstat-no" title="statement not covered" >wh+f*(v-wh);</span>let r,g,b;<span class="cstat-no" title="statement not covered" >switch(i){default:case 6:case 0:<span class="cstat-no" title="statement not covered" >r=v,g=n,b=wh;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 1:<span class="cstat-no" title="statement not covered" >r=n,g=v,b=wh;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >r=wh,g=v,b=n;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >r=wh,g=n,b=v;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >r=n,g=wh,b=v;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 5:<span class="cstat-no" title="statement not covered" >r=v,g=wh,b=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[255*r,255*g,255*b]}</span>,convert.cmyk.rgb=<span class="fstat-no" title="function not covered" >function(</span>cmyk){const c=<span class="cstat-no" title="statement not covered" >cmyk[0]/100,</span>m=<span class="cstat-no" title="statement not covered" >cmyk[1]/100,</span>y=<span class="cstat-no" title="statement not covered" >cmyk[2]/100,</span>k=<span class="cstat-no" title="statement not covered" >cmyk[3]/100;<span class="cstat-no" title="statement not covered" ></span>return[255*(1-Math.min(1,c*(1-k)+k)),255*(1-Math.min(1,m*(1-k)+k)),255*(1-Math.min(1,y*(1-k)+k))]}</span>,convert.xyz.rgb=<span class="fstat-no" title="function not covered" >function(</span>xyz){const x=<span class="cstat-no" title="statement not covered" >xyz[0]/100,</span>y=<span class="cstat-no" title="statement not covered" >xyz[1]/100,</span>z=<span class="cstat-no" title="statement not covered" >xyz[2]/100;</span>let r,g,b;<span class="cstat-no" title="statement not covered" >return r=3.2406*x+-1.5372*y+-.4986*z,g=-.9689*x+1.8758*y+.0415*z,b=.0557*x+-.204*y+1.057*z,r=r&gt;.0031308?1.055*r**(1/2.4)-.055:12.92*r,g=g&gt;.0031308?1.055*g**(1/2.4)-.055:12.92*g,b=b&gt;.0031308?1.055*b**(1/2.4)-.055:12.92*b,r=Math.min(Math.max(0,r),1),g=Math.min(Math.max(0,g),1),b=Math.min(Math.max(0,b),1),[255*r,255*g,255*b]}</span>,convert.xyz.lab=<span class="fstat-no" title="function not covered" >function(</span>xyz){let x=<span class="cstat-no" title="statement not covered" >xyz[0],</span>y=<span class="cstat-no" title="statement not covered" >xyz[1],</span>z=<span class="cstat-no" title="statement not covered" >xyz[2];<span class="cstat-no" title="statement not covered" ></span>x/=95.047,y/=100,z/=108.883,x=x&gt;.008856?x**(1/3):7.787*x+16/116,y=y&gt;.008856?y**(1/3):7.787*y+16/116,z=z&gt;.008856?z**(1/3):7.787*z+16/116;<span class="cstat-no" title="statement not covered" >r</span>eturn[116*y-16,500*(x-y),200*(y-z)]}</span>,convert.lab.xyz=<span class="fstat-no" title="function not covered" >function(</span>lab){let x,y,z;<span class="cstat-no" title="statement not covered" >y=(lab[0]+16)/116,x=lab[1]/500+y,z=y-lab[2]/200;c</span>onst y2=<span class="cstat-no" title="statement not covered" >y**3,</span>x2=<span class="cstat-no" title="statement not covered" >x**3,</span>z2=<span class="cstat-no" title="statement not covered" >z**3;<span class="cstat-no" title="statement not covered" ></span>return y=y2&gt;.008856?y2:(y-16/116)/7.787,x=x2&gt;.008856?x2:(x-16/116)/7.787,z=z2&gt;.008856?z2:(z-16/116)/7.787,x*=95.047,y*=100,z*=108.883,[x,y,z]}</span>,convert.lab.lch=<span class="fstat-no" title="function not covered" >function(</span>lab){const l=<span class="cstat-no" title="statement not covered" >lab[0],</span>a=<span class="cstat-no" title="statement not covered" >lab[1],</span>b=<span class="cstat-no" title="statement not covered" >lab[2];</span>let h;<span class="cstat-no" title="statement not covered" >h=360*Math.atan2(b,a)/2/Math.PI,h&lt;0&amp;&amp;(h+=360);<span class="cstat-no" title="statement not covered" >r</span>eturn[l,Math.sqrt(a*a+b*b),h]}</span>,convert.lch.lab=<span class="fstat-no" title="function not covered" >function(</span>lch){const l=<span class="cstat-no" title="statement not covered" >lch[0],</span>c=<span class="cstat-no" title="statement not covered" >lch[1],</span>hr=<span class="cstat-no" title="statement not covered" >lch[2]/360*2*Math.PI;<span class="cstat-no" title="statement not covered" ></span>return[l,c*Math.cos(hr),c*Math.sin(hr)]}</span>,convert.rgb.ansi16=<span class="fstat-no" title="function not covered" >function(</span>args,saturation=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{const[r,g,b]=<span class="cstat-no" title="statement not covered" >args;</span>let value=<span class="cstat-no" title="statement not covered" >null===saturation?convert.rgb.hsv(args)[2]:saturation;<span class="cstat-no" title="statement not covered" ></span>if(value=Math.round(value/50),0===value)<span class="cstat-no" title="statement not covered" >return 30;l</span></span>et ansi=<span class="cstat-no" title="statement not covered" >30+(Math.round(b/255)&lt;&lt;2|Math.round(g/255)&lt;&lt;1|Math.round(r/255));<span class="cstat-no" title="statement not covered" ></span>return 2===value&amp;&amp;(ansi+=60),ansi}</span>,convert.hsv.ansi16=<span class="fstat-no" title="function not covered" >function(</span>args){<span class="cstat-no" title="statement not covered" >return convert.rgb.ansi16(convert.hsv.rgb(args),args[2])}</span>,convert.rgb.ansi256=<span class="fstat-no" title="function not covered" >function(</span>args){const r=<span class="cstat-no" title="statement not covered" >args[0],</span>g=<span class="cstat-no" title="statement not covered" >args[1],</span>b=<span class="cstat-no" title="statement not covered" >args[2];<span class="cstat-no" title="statement not covered" ></span>if(r===g&amp;&amp;g===b)<span class="cstat-no" title="statement not covered" >return r&lt;8?16:r&gt;248?231:Math.round((r-8)/247*24)+232;<span class="cstat-no" title="statement not covered" >r</span></span>eturn 16+36*Math.round(r/255*5)+6*Math.round(g/255*5)+Math.round(b/255*5)}</span>,convert.ansi16.rgb=<span class="fstat-no" title="function not covered" >function(</span>args){let color=<span class="cstat-no" title="statement not covered" >args%10;<span class="cstat-no" title="statement not covered" ></span>if(0===color||7===color)<span class="cstat-no" title="statement not covered" >return args&gt;50&amp;&amp;(color+=3.5),color=color/10.5*255,[color,color,color];c</span></span>onst mult=<span class="cstat-no" title="statement not covered" >.5*(1+~~(args&gt;50));<span class="cstat-no" title="statement not covered" ></span>return[(1&amp;color)*mult*255,(color&gt;&gt;1&amp;1)*mult*255,(color&gt;&gt;2&amp;1)*mult*255]}</span>,convert.ansi256.rgb=<span class="fstat-no" title="function not covered" >function(</span>args){<span class="cstat-no" title="statement not covered" >if(args&gt;=232){const c=<span class="cstat-no" title="statement not covered" >10*(args-232)+8;<span class="cstat-no" title="statement not covered" ></span>return[c,c,c]}</span>l</span>et rem;<span class="cstat-no" title="statement not covered" >args-=16;<span class="cstat-no" title="statement not covered" >r</span>eturn[Math.floor(args/36)/5*255,Math.floor((rem=args%36)/6)/5*255,rem%6/5*255]}</span>,convert.rgb.hex=<span class="fstat-no" title="function not covered" >function(</span>args){const string=<span class="cstat-no" title="statement not covered" >(((255&amp;Math.round(args[0]))&lt;&lt;16)+((255&amp;Math.round(args[1]))&lt;&lt;8)+(255&amp;Math.round(args[2]))).toString(16).toUpperCase();<span class="cstat-no" title="statement not covered" ></span>return"000000".substring(string.length)+string}</span>,convert.hex.rgb=<span class="fstat-no" title="function not covered" >function(</span>args){const match=<span class="cstat-no" title="statement not covered" >args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);<span class="cstat-no" title="statement not covered" ></span>if(!match)<span class="cstat-no" title="statement not covered" >return[0,0,0];l</span></span>et colorString=<span class="cstat-no" title="statement not covered" >match[0];<span class="cstat-no" title="statement not covered" ></span>3===match[0].length&amp;&amp;(colorString=colorString.split("").map((<span class="fstat-no" title="function not covered" >char=</span>&gt;<span class="cstat-no" title="statement not covered" >char+char)</span>).join(""));c</span>onst integer=<span class="cstat-no" title="statement not covered" >parseInt(colorString,16);<span class="cstat-no" title="statement not covered" ></span>return[integer&gt;&gt;16&amp;255,integer&gt;&gt;8&amp;255,255&amp;integer]}</span>,convert.rgb.hcg=<span class="fstat-no" title="function not covered" >function(</span>rgb){const r=<span class="cstat-no" title="statement not covered" >rgb[0]/255,</span>g=<span class="cstat-no" title="statement not covered" >rgb[1]/255,</span>b=<span class="cstat-no" title="statement not covered" >rgb[2]/255,</span>max=<span class="cstat-no" title="statement not covered" >Math.max(Math.max(r,g),b),</span>min=<span class="cstat-no" title="statement not covered" >Math.min(Math.min(r,g),b),</span>chroma=<span class="cstat-no" title="statement not covered" >max-min;</span>let grayscale,hue;<span class="cstat-no" title="statement not covered" >return grayscale=chroma&lt;1?min/(1-chroma):0,hue=chroma&lt;=0?0:max===r?(g-b)/chroma%6:max===g?2+(b-r)/chroma:4+(r-g)/chroma,hue/=6,hue%=1,[360*hue,100*chroma,100*grayscale]}</span>,convert.hsl.hcg=<span class="fstat-no" title="function not covered" >function(</span>hsl){const s=<span class="cstat-no" title="statement not covered" >hsl[1]/100,</span>l=<span class="cstat-no" title="statement not covered" >hsl[2]/100,</span>c=<span class="cstat-no" title="statement not covered" >l&lt;.5?2*s*l:2*s*(1-l);</span>let f=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return c&lt;1&amp;&amp;(f=(l-.5*c)/(1-c)),[hsl[0],100*c,100*f]}</span>,convert.hsv.hcg=<span class="fstat-no" title="function not covered" >function(</span>hsv){const s=<span class="cstat-no" title="statement not covered" >hsv[1]/100,</span>v=<span class="cstat-no" title="statement not covered" >hsv[2]/100,</span>c=<span class="cstat-no" title="statement not covered" >s*v;</span>let f=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return c&lt;1&amp;&amp;(f=(v-c)/(1-c)),[hsv[0],100*c,100*f]}</span>,convert.hcg.rgb=<span class="fstat-no" title="function not covered" >function(</span>hcg){const h=<span class="cstat-no" title="statement not covered" >hcg[0]/360,</span>c=<span class="cstat-no" title="statement not covered" >hcg[1]/100,</span>g=<span class="cstat-no" title="statement not covered" >hcg[2]/100;<span class="cstat-no" title="statement not covered" ></span>if(0===c)<span class="cstat-no" title="statement not covered" >return[255*g,255*g,255*g];c</span></span>onst pure=<span class="cstat-no" title="statement not covered" >[0,0,0],</span>hi=<span class="cstat-no" title="statement not covered" >h%1*6,</span>v=<span class="cstat-no" title="statement not covered" >hi%1,</span>w=<span class="cstat-no" title="statement not covered" >1-v;</span>let mg=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>switch(Math.floor(hi)){case 0:<span class="cstat-no" title="statement not covered" >pure[0]=1,pure[1]=v,pure[2]=0;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 1:<span class="cstat-no" title="statement not covered" >pure[0]=w,pure[1]=1,pure[2]=0;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >pure[0]=0,pure[1]=1,pure[2]=v;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >pure[0]=0,pure[1]=w,pure[2]=1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >pure[0]=v,pure[1]=0,pure[2]=1;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >pure[0]=1,pure[1]=0,pure[2]=w}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn mg=(1-c)*g,[255*(c*pure[0]+mg),255*(c*pure[1]+mg),255*(c*pure[2]+mg)]}</span>,convert.hcg.hsv=<span class="fstat-no" title="function not covered" >function(</span>hcg){const c=<span class="cstat-no" title="statement not covered" >hcg[1]/100,</span>v=<span class="cstat-no" title="statement not covered" >c+hcg[2]/100*(1-c);</span>let f=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return v&gt;0&amp;&amp;(f=c/v),[hcg[0],100*f,100*v]}</span>,convert.hcg.hsl=<span class="fstat-no" title="function not covered" >function(</span>hcg){const c=<span class="cstat-no" title="statement not covered" >hcg[1]/100,</span>l=<span class="cstat-no" title="statement not covered" >hcg[2]/100*(1-c)+.5*c;</span>let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return l&gt;0&amp;&amp;l&lt;.5?s=c/(2*l):l&gt;=.5&amp;&amp;l&lt;1&amp;&amp;(s=c/(2*(1-l))),[hcg[0],100*s,100*l]}</span>,convert.hcg.hwb=<span class="fstat-no" title="function not covered" >function(</span>hcg){const c=<span class="cstat-no" title="statement not covered" >hcg[1]/100,</span>v=<span class="cstat-no" title="statement not covered" >c+hcg[2]/100*(1-c);<span class="cstat-no" title="statement not covered" ></span>return[hcg[0],100*(v-c),100*(1-v)]}</span>,convert.hwb.hcg=<span class="fstat-no" title="function not covered" >function(</span>hwb){const w=<span class="cstat-no" title="statement not covered" >hwb[1]/100,</span>v=<span class="cstat-no" title="statement not covered" >1-hwb[2]/100,</span>c=<span class="cstat-no" title="statement not covered" >v-w;</span>let g=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return c&lt;1&amp;&amp;(g=(v-c)/(1-c)),[hwb[0],100*c,100*g]}</span>,convert.apple.rgb=<span class="fstat-no" title="function not covered" >function(</span>apple){<span class="cstat-no" title="statement not covered" >return[apple[0]/65535*255,apple[1]/65535*255,apple[2]/65535*255]}</span>,convert.rgb.apple=<span class="fstat-no" title="function not covered" >function(</span>rgb){<span class="cstat-no" title="statement not covered" >return[rgb[0]/255*65535,rgb[1]/255*65535,rgb[2]/255*65535]}</span>,convert.gray.rgb=<span class="fstat-no" title="function not covered" >function(</span>args){<span class="cstat-no" title="statement not covered" >return[args[0]/100*255,args[0]/100*255,args[0]/100*255]}</span>,convert.gray.hsl=<span class="fstat-no" title="function not covered" >function(</span>args){<span class="cstat-no" title="statement not covered" >return[0,0,args[0]]}</span>,convert.gray.hsv=convert.gray.hsl,convert.gray.hwb=<span class="fstat-no" title="function not covered" >function(</span>gray){<span class="cstat-no" title="statement not covered" >return[0,100,gray[0]]}</span>,convert.gray.cmyk=<span class="fstat-no" title="function not covered" >function(</span>gray){<span class="cstat-no" title="statement not covered" >return[0,0,0,gray[0]]}</span>,convert.gray.lab=<span class="fstat-no" title="function not covered" >function(</span>gray){<span class="cstat-no" title="statement not covered" >return[gray[0],0,0]}</span>,convert.gray.hex=<span class="fstat-no" title="function not covered" >function(</span>gray){const val=<span class="cstat-no" title="statement not covered" >255&amp;Math.round(gray[0]/100*255),</span>string=<span class="cstat-no" title="statement not covered" >((val&lt;&lt;16)+(val&lt;&lt;8)+val).toString(16).toUpperCase();<span class="cstat-no" title="statement not covered" ></span>return"000000".substring(string.length)+string}</span>,convert.rgb.gray=<span class="fstat-no" title="function not covered" >function(</span>rgb){<span class="cstat-no" title="statement not covered" >return[(rgb[0]+rgb[1]+rgb[2])/3/255*100]}</span>}</span>,"./node_modules/color-convert/index.js":<span class="fstat-no" title="function not covered" >(m</span>odule,__unused_webpack_exports,__webpack_require__)=&gt;{const conversions=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/color-convert/conversions.js"),</span>route=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/color-convert/route.js"),</span>convert=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>Object.keys(conversions).forEach((<span class="fstat-no" title="function not covered" >fromModel=</span>&gt;{<span class="cstat-no" title="statement not covered" >convert[fromModel]={},Object.defineProperty(convert[fromModel],"channels",{value:conversions[fromModel].channels}),Object.defineProperty(convert[fromModel],"labels",{value:conversions[fromModel].labels});c</span>onst routes=<span class="cstat-no" title="statement not covered" >route(fromModel);<span class="cstat-no" title="statement not covered" ></span>Object.keys(routes).forEach((<span class="fstat-no" title="function not covered" >toModel=</span>&gt;{const fn=<span class="cstat-no" title="statement not covered" >routes[toModel];<span class="cstat-no" title="statement not covered" ></span>convert[fromModel][toModel]=function <span class="fstat-no" title="function not covered" >wrapRounded(</span>fn){const wrappedFn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>...args){const arg0=<span class="cstat-no" title="statement not covered" >args[0];<span class="cstat-no" title="statement not covered" ></span>if(null==arg0)<span class="cstat-no" title="statement not covered" >return arg0;<span class="cstat-no" title="statement not covered" >a</span></span>rg0.length&gt;1&amp;&amp;(args=arg0);c</span>onst result=<span class="cstat-no" title="statement not covered" >fn(args);<span class="cstat-no" title="statement not covered" ></span>if("object"==typeof result)<span class="cstat-no" title="statement not covered" >for(let len=<span class="cstat-no" title="statement not covered" >result.length,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;len;i++)<span class="cstat-no" title="statement not covered" >result[i]=Math.round(result[i]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn result}</span>;<span class="cstat-no" title="statement not covered" ></span>return"conversion"in fn&amp;&amp;(wrappedFn.conversion=fn.conversion),wrappedFn}</span>(fn),convert[fromModel][toModel].raw=function <span class="fstat-no" title="function not covered" >wrapRaw(</span>fn){const wrappedFn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>...args){const arg0=<span class="cstat-no" title="statement not covered" >args[0];<span class="cstat-no" title="statement not covered" ></span>return null==arg0?arg0:(arg0.length&gt;1&amp;&amp;(args=arg0),fn(args))}</span>;<span class="cstat-no" title="statement not covered" ></span>return"conversion"in fn&amp;&amp;(wrappedFn.conversion=fn.conversion),wrappedFn}</span>(fn)}</span>))}</span>)),module.exports=convert}</span>,"./node_modules/color-convert/route.js":<span class="fstat-no" title="function not covered" >(m</span>odule,__unused_webpack_exports,__webpack_require__)=&gt;{const conversions=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/color-convert/conversions.js");</span>function <span class="fstat-no" title="function not covered" >deriveBFS(</span>fromModel){const graph=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >buildGraph(</span>){const graph=<span class="cstat-no" title="statement not covered" >{},</span>models=<span class="cstat-no" title="statement not covered" >Object.keys(conversions);<span class="cstat-no" title="statement not covered" ></span>for(let len=<span class="cstat-no" title="statement not covered" >models.length,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;len;i++)<span class="cstat-no" title="statement not covered" >graph[models[i]]={distance:-1,parent:null};<span class="cstat-no" title="statement not covered" >r</span></span>eturn graph}</span>(),</span>queue=<span class="cstat-no" title="statement not covered" >[fromModel];<span class="cstat-no" title="statement not covered" ></span>for(graph[fromModel].distance=0;queue.length;){const current=<span class="cstat-no" title="statement not covered" >queue.pop(),</span>adjacents=<span class="cstat-no" title="statement not covered" >Object.keys(conversions[current]);<span class="cstat-no" title="statement not covered" ></span>for(let len=<span class="cstat-no" title="statement not covered" >adjacents.length,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;len;i++){const adjacent=<span class="cstat-no" title="statement not covered" >adjacents[i],</span>node=<span class="cstat-no" title="statement not covered" >graph[adjacent];<span class="cstat-no" title="statement not covered" ></span>-1===node.distance&amp;&amp;(node.distance=graph[current].distance+1,node.parent=current,queue.unshift(adjacent))}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn graph}</span>function <span class="fstat-no" title="function not covered" >link(</span>from,to){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >function(</span>args){<span class="cstat-no" title="statement not covered" >return to(from(args))}</span>}</span>function <span class="fstat-no" title="function not covered" >wrapConversion(</span>toModel,graph){const path=<span class="cstat-no" title="statement not covered" >[graph[toModel].parent,toModel];</span>let fn=<span class="cstat-no" title="statement not covered" >conversions[graph[toModel].parent][toModel],</span>cur=<span class="cstat-no" title="statement not covered" >graph[toModel].parent;<span class="cstat-no" title="statement not covered" ></span>for(;graph[cur].parent;)<span class="cstat-no" title="statement not covered" >path.unshift(graph[cur].parent),fn=link(conversions[graph[cur].parent][cur],fn),cur=graph[cur].parent;<span class="cstat-no" title="statement not covered" >r</span></span>eturn fn.conversion=path,fn}<span class="cstat-no" title="statement not covered" ></span>module.exports=<span class="fstat-no" title="function not covered" >function(</span>fromModel){const graph=<span class="cstat-no" title="statement not covered" >deriveBFS(fromModel),</span>conversion=<span class="cstat-no" title="statement not covered" >{},</span>models=<span class="cstat-no" title="statement not covered" >Object.keys(graph);<span class="cstat-no" title="statement not covered" ></span>for(let len=<span class="cstat-no" title="statement not covered" >models.length,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;len;i++){const toModel=<span class="cstat-no" title="statement not covered" >models[i];<span class="cstat-no" title="statement not covered" ></span>null!==graph[toModel].parent&amp;&amp;(conversion[toModel]=wrapConversion(toModel,graph))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn conversion}</span>}</span>,"./node_modules/color-name/index.js":<span class="fstat-no" title="function not covered" >module=</span>&gt;{"use strict";<span class="cstat-no" title="statement not covered" >module.exports={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}}</span>,"./node_modules/lodash/_baseTrim.js":<span class="fstat-no" title="function not covered" >(m</span>odule,__unused_webpack_exports,__webpack_require__)=&gt;{var trimmedEndIndex=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/lodash/_trimmedEndIndex.js"),</span>reTrimStart=<span class="cstat-no" title="statement not covered" >/^\s+/;<span class="cstat-no" title="statement not covered" ></span>module.exports=function <span class="fstat-no" title="function not covered" >baseTrim(</span>string){<span class="cstat-no" title="statement not covered" >return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,""):string}</span>}</span>,"./node_modules/lodash/_trimmedEndIndex.js":<span class="fstat-no" title="function not covered" >module=</span>&gt;{var reWhitespace=<span class="cstat-no" title="statement not covered" >/\s/;<span class="cstat-no" title="statement not covered" ></span>module.exports=function <span class="fstat-no" title="function not covered" >trimmedEndIndex(</span>string){<span class="cstat-no" title="statement not covered" >for(var index=<span class="cstat-no" title="statement not covered" >string.length;</span>index--&amp;&amp;reWhitespace.test(string.charAt(index)););<span class="cstat-no" title="statement not covered" >r</span>eturn index}</span>}</span>,"./node_modules/lodash/debounce.js":<span class="fstat-no" title="function not covered" >(m</span>odule,__unused_webpack_exports,__webpack_require__)=&gt;{var isObject=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/lodash/isObject.js"),</span>now=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/lodash/now.js"),</span>toNumber=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/lodash/toNumber.js"),</span>nativeMax=<span class="cstat-no" title="statement not covered" >Math.max,</span>nativeMin=<span class="cstat-no" title="statement not covered" >Math.min;<span class="cstat-no" title="statement not covered" ></span>module.exports=function <span class="fstat-no" title="function not covered" >debounce(</span>func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=<span class="cstat-no" title="statement not covered" >0,</span>leading=<span class="cstat-no" title="statement not covered" >!1,</span>maxing=<span class="cstat-no" title="statement not covered" >!1,</span>trailing=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>if("function"!=typeof func)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a function");f</span></span>unction <span class="fstat-no" title="function not covered" >invokeFunc(</span>time){var args=<span class="cstat-no" title="statement not covered" >lastArgs,</span>thisArg=<span class="cstat-no" title="statement not covered" >lastThis;<span class="cstat-no" title="statement not covered" ></span>return lastArgs=lastThis=void 0,lastInvokeTime=time,result=func.apply(thisArg,args)}</span>function <span class="fstat-no" title="function not covered" >shouldInvoke(</span>time){var timeSinceLastCall=<span class="cstat-no" title="statement not covered" >time-lastCallTime;<span class="cstat-no" title="statement not covered" ></span>return void 0===lastCallTime||timeSinceLastCall&gt;=wait||timeSinceLastCall&lt;0||maxing&amp;&amp;time-lastInvokeTime&gt;=maxWait}</span>function <span class="fstat-no" title="function not covered" >timerExpired(</span>){var time=<span class="cstat-no" title="statement not covered" >now();<span class="cstat-no" title="statement not covered" ></span>if(shouldInvoke(time))<span class="cstat-no" title="statement not covered" >return trailingEdge(time);<span class="cstat-no" title="statement not covered" >t</span></span>imerId=setTimeout(timerExpired,function <span class="fstat-no" title="function not covered" >remainingWait(</span>time){var timeWaiting=<span class="cstat-no" title="statement not covered" >wait-(time-lastCallTime);<span class="cstat-no" title="statement not covered" ></span>return maxing?nativeMin(timeWaiting,maxWait-(time-lastInvokeTime)):timeWaiting}</span>(time))}</span>function <span class="fstat-no" title="function not covered" >trailingEdge(</span>time){<span class="cstat-no" title="statement not covered" >return timerId=void 0,trailing&amp;&amp;lastArgs?invokeFunc(time):(lastArgs=lastThis=void 0,result)}</span>function <span class="fstat-no" title="function not covered" >debounced(</span>){var time=<span class="cstat-no" title="statement not covered" >now(),</span>isInvoking=<span class="cstat-no" title="statement not covered" >shouldInvoke(time);<span class="cstat-no" title="statement not covered" ></span>if(lastArgs=arguments,lastThis=this,lastCallTime=time,isInvoking){<span class="cstat-no" title="statement not covered" >if(void 0===timerId)<span class="cstat-no" title="statement not covered" >return function <span class="fstat-no" title="function not covered" >leadingEdge(</span>time){<span class="cstat-no" title="statement not covered" >return lastInvokeTime=time,timerId=setTimeout(timerExpired,wait),leading?invokeFunc(time):result}</span>(lastCallTime);<span class="cstat-no" title="statement not covered" >i</span></span>f(maxing)<span class="cstat-no" title="statement not covered" >return clearTimeout(timerId),timerId=setTimeout(timerExpired,wait),invokeFunc(lastCallTime)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn void 0===timerId&amp;&amp;(timerId=setTimeout(timerExpired,wait)),result}<span class="cstat-no" title="statement not covered" ></span>return wait=toNumber(wait)||0,isObject(options)&amp;&amp;(leading=!!options.leading,maxWait=(maxing="maxWait"in options)?nativeMax(toNumber(options.maxWait)||0,wait):maxWait,trailing="trailing"in options?!!options.trailing:trailing),debounced.cancel=function <span class="fstat-no" title="function not covered" >cancel(</span>){<span class="cstat-no" title="statement not covered" >void 0!==timerId&amp;&amp;clearTimeout(timerId),lastInvokeTime=0,lastArgs=lastCallTime=lastThis=timerId=void 0}</span>,debounced.flush=function <span class="fstat-no" title="function not covered" >flush(</span>){<span class="cstat-no" title="statement not covered" >return void 0===timerId?result:trailingEdge(now())}</span>,debounced}</span>}</span>,"./node_modules/lodash/now.js":<span class="fstat-no" title="function not covered" >(m</span>odule,__unused_webpack_exports,__webpack_require__)=&gt;{var root=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/lodash/_root.js");<span class="cstat-no" title="statement not covered" ></span>module.exports=<span class="fstat-no" title="function not covered" >function(</span>){<span class="cstat-no" title="statement not covered" >return root.Date.now()}</span>}</span>,"./node_modules/lodash/toNumber.js":<span class="fstat-no" title="function not covered" >(m</span>odule,__unused_webpack_exports,__webpack_require__)=&gt;{var baseTrim=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/lodash/_baseTrim.js"),</span>isObject=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/lodash/isObject.js"),</span>isSymbol=<span class="cstat-no" title="statement not covered" >__webpack_require__("./node_modules/lodash/isSymbol.js"),</span>reIsBadHex=<span class="cstat-no" title="statement not covered" >/^[-+]0x[0-9a-f]+$/i,</span>reIsBinary=<span class="cstat-no" title="statement not covered" >/^0b[01]+$/i,</span>reIsOctal=<span class="cstat-no" title="statement not covered" >/^0o[0-7]+$/i,</span>freeParseInt=<span class="cstat-no" title="statement not covered" >parseInt;<span class="cstat-no" title="statement not covered" ></span>module.exports=function <span class="fstat-no" title="function not covered" >toNumber(</span>value){<span class="cstat-no" title="statement not covered" >if("number"==typeof value)<span class="cstat-no" title="statement not covered" >return value;<span class="cstat-no" title="statement not covered" >i</span></span>f(isSymbol(value))<span class="cstat-no" title="statement not covered" >return NaN;<span class="cstat-no" title="statement not covered" >i</span></span>f(isObject(value)){var other=<span class="cstat-no" title="statement not covered" >"function"==typeof value.valueOf?value.valueOf():value;<span class="cstat-no" title="statement not covered" ></span>value=isObject(other)?other+"":other}<span class="cstat-no" title="statement not covered" ></span>i</span>f("string"!=typeof value)<span class="cstat-no" title="statement not covered" >return 0===value?value:+value;<span class="cstat-no" title="statement not covered" >v</span></span>alue=baseTrim(value);v</span>ar isBinary=<span class="cstat-no" title="statement not covered" >reIsBinary.test(value);<span class="cstat-no" title="statement not covered" ></span>return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NaN:+value}</span>}</span>}]);</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2024-09-23T07:51:25.434Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    